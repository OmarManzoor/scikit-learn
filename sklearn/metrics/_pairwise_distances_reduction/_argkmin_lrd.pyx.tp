from cython cimport floating, integral
from cython.parallel cimport prange
from libc.math cimport fmax
from libc.stdlib cimport free

from ...utils._typedefs cimport intp_t, float64_t
from ...utils.fixes import threadpool_limits

import numpy as np


cdef float64_t EPS = 1e-10

{{for name_suffix in ["32", "64"]}}

from ._argkmin cimport ArgKmin{{name_suffix}}
from ._datasets_pair cimport DatasetsPair{{name_suffix}}

cdef class ArgKminLRD{{name_suffix}}(ArgKmin{{name_suffix}}):
    """
    {{name_suffix}}bit implementation of ArgKminLRD. Current
    implementation supports the fit method of LocalOutlierFactor.
    """
    cdef:
        float64_t[::1] lrd
        float64_t[:, ::1] actual_distances
        intp_t[:, ::1] actual_indices

    @classmethod
    def compute(
        cls,
        X,
        Y,
        intp_t k,
        str metric="euclidean",
        chunk_size=None,
        dict metric_kwargs=None,
        str strategy=None,
        bint return_distance=False,
    ):
        # Use a generic implementation that handles most scipy
        # metrics by computing the distances between 2 vectors at a time.
        pda = ArgKminLRD{{name_suffix}}(
            datasets_pair=DatasetsPair{{name_suffix}}.get_for(X, Y, metric, metric_kwargs),
            k=k,
            chunk_size=chunk_size,
            strategy=strategy,
        )

        # Limit the number of threads in second level of nested parallelism for BLAS
        # to avoid threads over-subscription (in GEMM for instance).
        with threadpool_limits(limits=1, user_api="blas"):
            if pda.execute_in_parallel_on_Y:
                pda._parallel_on_Y()
            else:
                pda._parallel_on_X()

        return pda._finalize_results(return_distance)

    def __init__(
        self,
        DatasetsPair{{name_suffix}} datasets_pair,
        chunk_size=None,
        strategy=None,
        intp_t k=1,
    ):
        super().__init__(
            datasets_pair=datasets_pair,
            chunk_size=chunk_size,
            strategy=strategy,
            k=k,
        )

        self.lrd = np.zeros(self.n_samples_X, dtype=np.float64)

        # Current implementation of ArgKminLRD is used in the fit method
        # of the LocalOutlierFactor. When it is called from fit the
        # number of neighbors are actually set to one more than the actual
        # number of neighbors. There we would actually get k + 1. However
        # the first neighbor is actually ignored when doing the computation.
        # This is why the number of neighbors below is set to k - 1.
        self.actual_distances = np.zeros(
            (self.n_samples_X, self.k - 1), dtype=np.float64
        )
        self.actual_indices = np.zeros(
            (self.n_samples_X, self.k - 1), dtype=np.intp
        )

    cdef inline void _compute_local_reachability_density(
        self,
        bint return_distance,
    ) noexcept nogil:
        cdef:
            intp_t sample_index, neighbor_rank, neighbor_idx
            float64_t dist_sample, dist_neighbor, dist_reach
            float64_t overall_reachability

        for sample_index in prange(
            self.n_samples_X,
            schedule='static',
            nogil=True,
            num_threads=self.effective_n_threads,
        ):
            overall_reachability = 0
            # Since the first neighbor is ignored when calling ArgKminLRD from
            # the fit method of the LocalOutlierFactor we simply start the loop
            # from 1.
            for neighbor_rank in range(1, self.k):
                neighbor_idx = self.argkmin_indices[sample_index, neighbor_rank]
                dist_sample = self.datasets_pair.distance_metric._rdist_to_dist(
                    fmax(self.argkmin_distances[sample_index, neighbor_rank], 0.0)
                )
                dist_neighbor = self.datasets_pair.distance_metric._rdist_to_dist(
                    fmax(self.argkmin_distances[neighbor_idx, self.k - 1], 0.0)
                )
                dist_reach = fmax(dist_sample, dist_neighbor)
                overall_reachability += dist_reach
                # For actual indices and actual distances we need to fill the
                # arrays starting from neighbor index = 0 thus we subtract 1
                # here.
                self.actual_indices[sample_index, neighbor_rank - 1] = neighbor_idx
                if return_distance:
                    self.actual_distances[sample_index, neighbor_rank - 1] = dist_sample

            # self.k - 1 is the actual number of neighbors ignoring the
            # first extra one.
            overall_reachability = overall_reachability / (self.k - 1)
            self.lrd[sample_index] = 1.0 / (overall_reachability + EPS)

    def _finalize_results(self, bint return_distance):
        self._compute_local_reachability_density(return_distance=return_distance)
        if return_distance:
            return (
                np.asarray(self.lrd),
                np.asarray(self.actual_indices),
                np.asarray(self.actual_distances),
            )
        return np.asarray(self.lrd), np.asarray(self.actual_indices)

{{endfor}}
